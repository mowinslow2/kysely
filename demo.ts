import {
  Kysely,
  PostgresDialect,
  Generated,
  ColumnType,
} from 'kysely'
import pkg from 'pg';
const { Pool } = pkg;

type User = {
  name: string
  city: string
  address: string
  prefix: 'Mr' | 'Mrs' | 'Ms' | 'Dr' | null
}

type Order = {
  user_id: string // Foreign key
  product_name: string 
  quantity: number
}

interface UsersTable {
  // Columns that are generated by the database should be marked
  // using the `Generated` type. This way they are automatically
  // made optional in inserts and updates.
  id: Generated<string>

  city: string
  name: string
  address: string

  // If the column is nullable in the database, make its type nullable.
  // Don't use optional properties. Optionality is always determined
  // automatically by Kysely.
  prefix: 'Mr' | 'Mrs' | 'Ms' | 'Dr' | null

  // You can specify a different type for each operation (select, insert and
  // update) using the `ColumnType<SelectType, InsertType, UpdateType>`
  // wrapper. Here we define a column `modified_at` that is selected as
  // a `Date`, can optionally be provided as a `string` in inserts and
  // can never be updated:
  modified_at: ColumnType<Date, string | undefined, never>
}

interface OrdersTable {
  id: Generated<string>
  user_id: string
  product_name: string
  quantity: number
}

// Keys of this interface are table names.
interface Database {
  users: UsersTable
  orders: OrdersTable
}

// You'd create one of these when you start your app.
const db = new Kysely<Database>({
  dialect: new PostgresDialect({
    pool: new Pool({
      connectionString: 'postgresql://morgan:u_HWIkgQZ0tIDMGs_tv8Xw@morgan-serverless-6048.7tt.cockroachlabs.cloud:26257/demo?sslmode=verify-full'
    })
  })
})

// INSERT user
async function insertUser(user:User) {
  try {
    const { id } = await db.insertInto('users').values(user).returning('id').executeTakeFirstOrThrow()
    
    if (id) {
      console.log('User ' + user.name + ' was added with ID ' + id)
      return id;
    } else {
      throw new Error('No id returned when adding a user!')
    }
    
  } catch (error) {
    console.log('ERROR: ', error)
    return;
  }
}

// INSERT order
async function insertOrder(order:Order) {
  try {
    const { id } = await db.insertInto('orders').values(order).returning('id').executeTakeFirstOrThrow()
    
    if (id) {
      console.log('Order was added with ID ' + id)
      return id;
    } else {
      throw new Error('No id returned when adding an order!')
    }
    
  } catch (error) {
    console.log('ERROR: ', error)
    return;
  }
}

// SELECT user
async function getUser(id:string) {
  try {
    const user = await db.selectFrom('users').select(['name', 'address', 'city']).where('id', '=', id).executeTakeFirst()
    return user;
  } catch (error) {
    console.log('ERROR: ', error)
    return;
  }
}

// JOIN users and orders table
async function getUserOrder(name:string) {
  const order = await db
      .selectFrom('users')
      .innerJoin('orders', 'orders.user_id', 'users.id')
      .select(['name', 'product_name', 'quantity'])
      .where('name', '=', name)
      .executeTakeFirstOrThrow()
  
  return order
}

/*
1. Insert user 'Morgan' into users table
2. Select user from newly created userID and print results
3. Insert order into orders table
4. Select all orders for a user, given a users name (JOIN example)
*/

// "User Input"
const name = 'Morgan'
const address = '1234 cockroach way'
const city = 'New York City'

const user:User = {
  name: name,
  address: address,
  city: city,
  prefix: null
}

const userId = await insertUser(user)
let orderId

if (userId) {
  const userInfo = await getUser(userId)
  if (userInfo) {
    console.log("Morgan's address is: " + userInfo.address + ', ' + userInfo.city)
  } else {
    console.log("No user found with that name!")
  }

  const order:Order = {
    user_id: userId,
    product_name: 'computer',
    quantity: 1
  }
  orderId = await insertOrder(order)
}

if (orderId) {
  const orderInfo = await getUserOrder(name)
  if (orderInfo) {
    console.log("Order Info: " + orderInfo.name + ", " + orderInfo.product_name + ", " + orderInfo.quantity)
  }
}


